; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu | FileCheck %s

; Test that we don't bitcast loads from integer vectors to large illegal scalars.
; The threshold is 2*pointer_size (128 bits on x86-64).

; i192 is just above the threshold - should NOT bitcast even through freeze
define i192 @load_v3i64_to_i192_freeze(ptr %p) nounwind {
; CHECK-LABEL: load_v3i64_to_i192_freeze:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq (%rdi), %rax
; CHECK-NEXT:    movq 8(%rdi), %rdx
; CHECK-NEXT:    movq 16(%rdi), %rcx
; CHECK-NEXT:    retq
  %vec = load <3 x i64>, ptr %p
  %freeze = freeze <3 x i64> %vec
  %result = bitcast <3 x i64> %freeze to i192
  ret i192 %result
}

; i128 is at the threshold - should allow bitcast through freeze
define i128 @load_v2i64_to_i128_freeze(ptr %p) nounwind {
; CHECK-LABEL: load_v2i64_to_i128_freeze:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq (%rdi), %rax
; CHECK-NEXT:    movq 8(%rdi), %rdx
; CHECK-NEXT:    retq
  %vec = load <2 x i64>, ptr %p
  %freeze = freeze <2 x i64> %vec
  %result = bitcast <2 x i64> %freeze to i128
  ret i128 %result
}

; Test with i256 (way above threshold)
define i256 @load_v4i64_to_i256_freeze(ptr %p) nounwind {
; CHECK-LABEL: load_v4i64_to_i256_freeze:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %rdi, %rax
; CHECK-NEXT:    movaps (%rsi), %xmm0
; CHECK-NEXT:    movaps 16(%rsi), %xmm1
; CHECK-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK-NEXT:    movaps %xmm0, (%rdi)
; CHECK-NEXT:    retq
  %vec = load <4 x i64>, ptr %p
  %freeze = freeze <4 x i64> %vec
  %result = bitcast <4 x i64> %freeze to i256
  ret i256 %result
}

; Test with i160 (also above threshold)
define i160 @load_v5i32_to_i160_freeze(ptr %p) nounwind {
; CHECK-LABEL: load_v5i32_to_i160_freeze:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq (%rdi), %rax
; CHECK-NEXT:    movq 8(%rdi), %rdx
; CHECK-NEXT:    movl 16(%rdi), %ecx
; CHECK-NEXT:    movl %ecx, %ecx
; CHECK-NEXT:    retq
  %vec = load <5 x i32>, ptr %p
  %freeze = freeze <5 x i32> %vec
  %result = bitcast <5 x i32> %freeze to i160
  ret i160 %result
}

; FP vectors should still be allowed to bitcast through freeze
define double @load_v2f32_to_f64_freeze(ptr %p) nounwind {
; CHECK-LABEL: load_v2f32_to_f64_freeze:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    retq
  %vec = load <2 x float>, ptr %p
  %freeze = freeze <2 x float> %vec
  %result = bitcast <2 x float> %freeze to double
  ret double %result
}
