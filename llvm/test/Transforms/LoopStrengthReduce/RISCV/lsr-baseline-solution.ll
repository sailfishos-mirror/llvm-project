; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -O3 -mattr=+v -lsr-drop-solution | FileCheck --check-prefix=CHECK_DROP %s
; RUN: llc < %s -O3 -mattr=+v -lsr-drop-solution=false | FileCheck --check-prefix=CHECK_NODROP %s

target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Each of these test cases, the solution is dropped as the solution is equal
; to the baseline. We used to apply the LSR solution in these scenarios.

define void @_Z4add1PiS_(ptr %x, ptr %end) {
; CHECK_DROP-LABEL: _Z4add1PiS_:
; CHECK_DROP:       # %bb.0: # %entry
; CHECK_DROP-NEXT:    beq a0, a1, .LBB0_2
; CHECK_DROP-NEXT:  .LBB0_1: # %for.body
; CHECK_DROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_DROP-NEXT:    lw a2, 0(a0)
; CHECK_DROP-NEXT:    addi a2, a2, 1
; CHECK_DROP-NEXT:    sw a2, 0(a0)
; CHECK_DROP-NEXT:    addi a0, a0, 4
; CHECK_DROP-NEXT:    bne a0, a1, .LBB0_1
; CHECK_DROP-NEXT:  .LBB0_2: # %for.end
; CHECK_DROP-NEXT:    ret
;
; CHECK_NODROP-LABEL: _Z4add1PiS_:
; CHECK_NODROP:       # %bb.0: # %entry
; CHECK_NODROP-NEXT:    beq a0, a1, .LBB0_2
; CHECK_NODROP-NEXT:  .LBB0_1: # %for.body
; CHECK_NODROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_NODROP-NEXT:    lw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a2, a2, 1
; CHECK_NODROP-NEXT:    sw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a0, a0, 4
; CHECK_NODROP-NEXT:    bne a0, a1, .LBB0_1
; CHECK_NODROP-NEXT:  .LBB0_2: # %for.end
; CHECK_NODROP-NEXT:    ret
entry:
  %cmp.not3 = icmp eq ptr %x, %end
  br i1 %cmp.not3, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %x.addr.04 = phi ptr [ %incdec.ptr, %for.body ], [ %x, %entry ]
  %0 = load i32, ptr %x.addr.04, align 4, !tbaa !9
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr %x.addr.04, align 4, !tbaa !9
  %incdec.ptr = getelementptr inbounds nuw i8, ptr %x.addr.04, i64 4
  %cmp.not = icmp eq ptr %incdec.ptr, %end
  br i1 %cmp.not, label %for.end, label %for.body, !llvm.loop !13

for.end:                                          ; preds = %for.body, %entry
  ret void
}

define void @_Z6add1_iPim(ptr %x, i64 %n) {
; CHECK_DROP-LABEL: _Z6add1_iPim:
; CHECK_DROP:       # %bb.0: # %entry
; CHECK_DROP-NEXT:    beqz a1, .LBB1_3
; CHECK_DROP-NEXT:  # %bb.1: # %for.body.preheader
; CHECK_DROP-NEXT:    li a2, 0
; CHECK_DROP-NEXT:  .LBB1_2: # %for.body
; CHECK_DROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_DROP-NEXT:    slli a3, a2, 2
; CHECK_DROP-NEXT:    add a3, a0, a3
; CHECK_DROP-NEXT:    lw a4, 0(a3)
; CHECK_DROP-NEXT:    addi a4, a4, 1
; CHECK_DROP-NEXT:    addi a2, a2, 1
; CHECK_DROP-NEXT:    sw a4, 0(a3)
; CHECK_DROP-NEXT:    bne a2, a1, .LBB1_2
; CHECK_DROP-NEXT:  .LBB1_3: # %for.cond.cleanup
; CHECK_DROP-NEXT:    ret
;
; CHECK_NODROP-LABEL: _Z6add1_iPim:
; CHECK_NODROP:       # %bb.0: # %entry
; CHECK_NODROP-NEXT:    beqz a1, .LBB1_3
; CHECK_NODROP-NEXT:  # %bb.1: # %for.body.preheader
; CHECK_NODROP-NEXT:    slli a1, a1, 2
; CHECK_NODROP-NEXT:    add a1, a0, a1
; CHECK_NODROP-NEXT:  .LBB1_2: # %for.body
; CHECK_NODROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_NODROP-NEXT:    lw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a2, a2, 1
; CHECK_NODROP-NEXT:    sw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a0, a0, 4
; CHECK_NODROP-NEXT:    bne a0, a1, .LBB1_2
; CHECK_NODROP-NEXT:  .LBB1_3: # %for.cond.cleanup
; CHECK_NODROP-NEXT:    ret
entry:
  %cmp.not4 = icmp eq i64 %n, 0
  br i1 %cmp.not4, label %for.cond.cleanup, label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.05 = phi i64 [ %inc1, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds nuw i32, ptr %x, i64 %i.05
  %0 = load i32, ptr %arrayidx, align 4, !tbaa !9
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr %arrayidx, align 4, !tbaa !9
  %inc1 = add nuw i64 %i.05, 1
  %cmp.not = icmp eq i64 %inc1, %n
  br i1 %cmp.not, label %for.cond.cleanup, label %for.body, !llvm.loop !15
}

define void @_Z6add1_nPim(ptr %x, i64 %n) {
; CHECK_DROP-LABEL: _Z6add1_nPim:
; CHECK_DROP:       # %bb.0: # %entry
; CHECK_DROP-NEXT:    beqz a1, .LBB2_3
; CHECK_DROP-NEXT:  # %bb.1: # %for.body.i.preheader
; CHECK_DROP-NEXT:    slli a1, a1, 2
; CHECK_DROP-NEXT:    add a1, a0, a1
; CHECK_DROP-NEXT:  .LBB2_2: # %for.body.i
; CHECK_DROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_DROP-NEXT:    lw a2, 0(a0)
; CHECK_DROP-NEXT:    addi a2, a2, 1
; CHECK_DROP-NEXT:    sw a2, 0(a0)
; CHECK_DROP-NEXT:    addi a0, a0, 4
; CHECK_DROP-NEXT:    bne a0, a1, .LBB2_2
; CHECK_DROP-NEXT:  .LBB2_3: # %_Z4add1PiS_.exit
; CHECK_DROP-NEXT:    ret
;
; CHECK_NODROP-LABEL: _Z6add1_nPim:
; CHECK_NODROP:       # %bb.0: # %entry
; CHECK_NODROP-NEXT:    beqz a1, .LBB2_3
; CHECK_NODROP-NEXT:  # %bb.1: # %for.body.i.preheader
; CHECK_NODROP-NEXT:    slli a1, a1, 2
; CHECK_NODROP-NEXT:  .LBB2_2: # %for.body.i
; CHECK_NODROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_NODROP-NEXT:    lw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a1, a1, -4
; CHECK_NODROP-NEXT:    addi a2, a2, 1
; CHECK_NODROP-NEXT:    sw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a0, a0, 4
; CHECK_NODROP-NEXT:    bnez a1, .LBB2_2
; CHECK_NODROP-NEXT:  .LBB2_3: # %_Z4add1PiS_.exit
; CHECK_NODROP-NEXT:    ret
entry:
  %add.ptr = getelementptr inbounds nuw i32, ptr %x, i64 %n
  %cmp.not3.i = icmp eq i64 %n, 0
  br i1 %cmp.not3.i, label %_Z4add1PiS_.exit, label %for.body.i

for.body.i:                                       ; preds = %entry, %for.body.i
  %x.addr.04.i = phi ptr [ %incdec.ptr.i, %for.body.i ], [ %x, %entry ]
  %0 = load i32, ptr %x.addr.04.i, align 4, !tbaa !9
  %inc.i = add nsw i32 %0, 1
  store i32 %inc.i, ptr %x.addr.04.i, align 4, !tbaa !9
  %incdec.ptr.i = getelementptr inbounds nuw i8, ptr %x.addr.04.i, i64 4
  %cmp.not.i = icmp eq ptr %incdec.ptr.i, %add.ptr
  br i1 %cmp.not.i, label %_Z4add1PiS_.exit, label %for.body.i, !llvm.loop !13

_Z4add1PiS_.exit:                                 ; preds = %for.body.i, %entry
  ret void
}

define void @_Z6add1_2PiS_(ptr %x, ptr %end) {
; CHECK_DROP-LABEL: _Z6add1_2PiS_:
; CHECK_DROP:       # %bb.0: # %entry
; CHECK_DROP-NEXT:    beq a1, a0, .LBB3_3
; CHECK_DROP-NEXT:  # %bb.1: # %for.body.preheader
; CHECK_DROP-NEXT:    li a2, 0
; CHECK_DROP-NEXT:    sub a1, a1, a0
; CHECK_DROP-NEXT:    srai a1, a1, 2
; CHECK_DROP-NEXT:  .LBB3_2: # %for.body
; CHECK_DROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_DROP-NEXT:    slli a3, a2, 2
; CHECK_DROP-NEXT:    add a3, a0, a3
; CHECK_DROP-NEXT:    lw a4, 0(a3)
; CHECK_DROP-NEXT:    addi a4, a4, 1
; CHECK_DROP-NEXT:    addi a2, a2, 1
; CHECK_DROP-NEXT:    sw a4, 0(a3)
; CHECK_DROP-NEXT:    bne a2, a1, .LBB3_2
; CHECK_DROP-NEXT:  .LBB3_3: # %for.cond.cleanup
; CHECK_DROP-NEXT:    ret
;
; CHECK_NODROP-LABEL: _Z6add1_2PiS_:
; CHECK_NODROP:       # %bb.0: # %entry
; CHECK_NODROP-NEXT:    beq a1, a0, .LBB3_3
; CHECK_NODROP-NEXT:  # %bb.1:
; CHECK_NODROP-NEXT:    sub a1, a1, a0
; CHECK_NODROP-NEXT:    srai a1, a1, 2
; CHECK_NODROP-NEXT:  .LBB3_2: # %for.body
; CHECK_NODROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_NODROP-NEXT:    lw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a1, a1, -1
; CHECK_NODROP-NEXT:    addi a2, a2, 1
; CHECK_NODROP-NEXT:    sw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a0, a0, 4
; CHECK_NODROP-NEXT:    bnez a1, .LBB3_2
; CHECK_NODROP-NEXT:  .LBB3_3: # %for.cond.cleanup
; CHECK_NODROP-NEXT:    ret
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %end to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %x to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 2
  %cmp.not5 = icmp eq ptr %end, %x
  br i1 %cmp.not5, label %for.cond.cleanup, label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.06 = phi i64 [ %inc1, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds nuw i32, ptr %x, i64 %i.06
  %0 = load i32, ptr %arrayidx, align 4, !tbaa !9
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr %arrayidx, align 4, !tbaa !9
  %inc1 = add i64 %i.06, 1
  %cmp.not = icmp eq i64 %inc1, %sub.ptr.div
  br i1 %cmp.not, label %for.cond.cleanup, label %for.body, !llvm.loop !16
}

define void @_Z6add1_3PiS_(ptr %x, ptr %end) {
; CHECK_DROP-LABEL: _Z6add1_3PiS_:
; CHECK_DROP:       # %bb.0: # %entry
; CHECK_DROP-NEXT:    beq a1, a0, .LBB4_3
; CHECK_DROP-NEXT:  # %bb.1: # %for.body.i.preheader
; CHECK_DROP-NEXT:    li a2, 0
; CHECK_DROP-NEXT:    sub a1, a1, a0
; CHECK_DROP-NEXT:    srai a1, a1, 2
; CHECK_DROP-NEXT:  .LBB4_2: # %for.body.i
; CHECK_DROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_DROP-NEXT:    slli a3, a2, 2
; CHECK_DROP-NEXT:    add a3, a0, a3
; CHECK_DROP-NEXT:    lw a4, 0(a3)
; CHECK_DROP-NEXT:    addi a4, a4, 1
; CHECK_DROP-NEXT:    addi a2, a2, 1
; CHECK_DROP-NEXT:    sw a4, 0(a3)
; CHECK_DROP-NEXT:    bne a2, a1, .LBB4_2
; CHECK_DROP-NEXT:  .LBB4_3: # %_Z6add1_iPim.exit
; CHECK_DROP-NEXT:    ret
;
; CHECK_NODROP-LABEL: _Z6add1_3PiS_:
; CHECK_NODROP:       # %bb.0: # %entry
; CHECK_NODROP-NEXT:    beq a1, a0, .LBB4_3
; CHECK_NODROP-NEXT:  # %bb.1: # %for.body.i.preheader
; CHECK_NODROP-NEXT:    sub a1, a1, a0
; CHECK_NODROP-NEXT:    srai a1, a1, 2
; CHECK_NODROP-NEXT:    slli a1, a1, 2
; CHECK_NODROP-NEXT:    add a1, a0, a1
; CHECK_NODROP-NEXT:  .LBB4_2: # %for.body.i
; CHECK_NODROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_NODROP-NEXT:    lw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a2, a2, 1
; CHECK_NODROP-NEXT:    sw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a0, a0, 4
; CHECK_NODROP-NEXT:    bne a0, a1, .LBB4_2
; CHECK_NODROP-NEXT:  .LBB4_3: # %_Z6add1_iPim.exit
; CHECK_NODROP-NEXT:    ret
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %end to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %x to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub, 2
  %cmp.not4.i = icmp eq ptr %end, %x
  br i1 %cmp.not4.i, label %_Z6add1_iPim.exit, label %for.body.i

for.body.i:                                       ; preds = %entry, %for.body.i
  %i.05.i = phi i64 [ %inc1.i, %for.body.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr inbounds nuw i32, ptr %x, i64 %i.05.i
  %0 = load i32, ptr %arrayidx.i, align 4, !tbaa !9
  %inc.i = add nsw i32 %0, 1
  store i32 %inc.i, ptr %arrayidx.i, align 4, !tbaa !9
  %inc1.i = add nuw i64 %i.05.i, 1
  %cmp.not.i = icmp eq i64 %inc1.i, %sub.ptr.div
  br i1 %cmp.not.i, label %_Z6add1_iPim.exit, label %for.body.i, !llvm.loop !15

_Z6add1_iPim.exit:                                ; preds = %for.body.i, %entry
  ret void
}

define void @_Z6add1_sSt4spanIiLm18446744073709551615EE([2 x i64] %r.coerce) {
; CHECK_DROP-LABEL: _Z6add1_sSt4spanIiLm18446744073709551615EE:
; CHECK_DROP:       # %bb.0: # %entry
; CHECK_DROP-NEXT:    beqz a1, .LBB5_3
; CHECK_DROP-NEXT:  # %bb.1: # %for.body.preheader
; CHECK_DROP-NEXT:    slli a1, a1, 2
; CHECK_DROP-NEXT:    add a1, a0, a1
; CHECK_DROP-NEXT:  .LBB5_2: # %for.body
; CHECK_DROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_DROP-NEXT:    lw a2, 0(a0)
; CHECK_DROP-NEXT:    addi a2, a2, 1
; CHECK_DROP-NEXT:    sw a2, 0(a0)
; CHECK_DROP-NEXT:    addi a0, a0, 4
; CHECK_DROP-NEXT:    bne a0, a1, .LBB5_2
; CHECK_DROP-NEXT:  .LBB5_3: # %for.cond.cleanup
; CHECK_DROP-NEXT:    ret
;
; CHECK_NODROP-LABEL: _Z6add1_sSt4spanIiLm18446744073709551615EE:
; CHECK_NODROP:       # %bb.0: # %entry
; CHECK_NODROP-NEXT:    beqz a1, .LBB5_3
; CHECK_NODROP-NEXT:  # %bb.1: # %for.body.preheader
; CHECK_NODROP-NEXT:    slli a1, a1, 2
; CHECK_NODROP-NEXT:  .LBB5_2: # %for.body
; CHECK_NODROP-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK_NODROP-NEXT:    lw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a1, a1, -4
; CHECK_NODROP-NEXT:    addi a2, a2, 1
; CHECK_NODROP-NEXT:    sw a2, 0(a0)
; CHECK_NODROP-NEXT:    addi a0, a0, 4
; CHECK_NODROP-NEXT:    bnez a1, .LBB5_2
; CHECK_NODROP-NEXT:  .LBB5_3: # %for.cond.cleanup
; CHECK_NODROP-NEXT:    ret
entry:
  %r.coerce.fca.0.extract = extractvalue [2 x i64] %r.coerce, 0
  %0 = inttoptr i64 %r.coerce.fca.0.extract to ptr
  %r.coerce.fca.1.extract = extractvalue [2 x i64] %r.coerce, 1
  %add.ptr.i = getelementptr inbounds nuw i32, ptr %0, i64 %r.coerce.fca.1.extract
  %cmp.i12 = icmp eq i64 %r.coerce.fca.1.extract, 0
  br i1 %cmp.i12, label %for.cond.cleanup, label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %entry, %for.body
  %__begin1.sroa.0.013 = phi ptr [ %incdec.ptr.i, %for.body ], [ %0, %entry ]
  %1 = load i32, ptr %__begin1.sroa.0.013, align 4, !tbaa !9
  %inc = add nsw i32 %1, 1
  store i32 %inc, ptr %__begin1.sroa.0.013, align 4, !tbaa !9
  %incdec.ptr.i = getelementptr inbounds nuw i8, ptr %__begin1.sroa.0.013, i64 4
  %cmp.i = icmp eq ptr %incdec.ptr.i, %add.ptr.i
  br i1 %cmp.i, label %for.cond.cleanup, label %for.body
}

!9 = !{!10, !10, i64 0}
!10 = !{!"int", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = distinct !{!13, !14}
!14 = !{!"llvm.loop.mustprogress"}
!15 = distinct !{!15, !14}
!16 = distinct !{!16, !14}
